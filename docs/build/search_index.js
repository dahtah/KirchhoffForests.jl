var documenterSearchIndex = {"docs":
[{"location":"#KirchhoffForests.jl:-a-Julia-package-for-Random-Forests-on-Graphs,-and-Applications","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"","category":"section"},{"location":"#What's-a-random-forest?","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"What's a random forest?","text":"","category":"section"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"The random forests produced by this package come from graph theory, and are unrelated to the random forests found in machine learning. A tree is a graph without cycles, and a forest is a set of trees.  We are interested in a specific way of generating random spanning forests in a graph, because of its deep ties to the graph Laplacian. ","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"using Graphs,TikzPictures,TikzGraphs\ng = grid([2,2])\nadd_vertex!(g)\nadd_edge!(g,4,5)\nt = TikzGraphs.plot(g)\nsave(SVG(\"ex_graph.svg\"),t)\n\ng2 = SimpleDiGraph(5)\nadd_edge!(g2,2,1)\nadd_edge!(g2,1,4)\nadd_edge!(g2,4,5)\nadd_edge!(g2,3,5)\nt = TikzGraphs.plot(g2)\nsave(SVG(\"ex_tree.svg\"),t)\n\ng3 = SimpleDiGraph(5)\nadd_edge!(g3,2,3)\nadd_edge!(g3,1,4)\nadd_edge!(g3,4,5)\n\nt = TikzGraphs.plot(g3)\nsave(SVG(\"ex_forest.svg\"),t)","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"This is an example of a graph (with a loop):","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"(Image: )","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"This is an example of a spanning tree for the (same) graph:","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"(Image: )","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"Finally, this is an example of a spanning forest:","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"(Image: )","category":"page"},{"location":"#Rooted-spanning-forests","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"Rooted spanning forests","text":"","category":"section"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"Importantly, all the forests we use are considered to be rooted: each tree in the forest is directed, and all edges point towards the root of the tree. In the forest above, the roots are the nodes 5 and 3. ","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"When we talk about a \"random spanning forest\", we mean a forest phi sampled from the following distribution: ","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"p(phi) = frac1z q^R(phi) prod_(ij)in phi w_ij","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"where:","category":"page"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"$ \\phi $ is a forest, viewed as a set of edges,\n$ R(\\phi) $ is the number of trees in phi,\n$ w_{ij} $ is the weight associated with edge (ij) (which equals 1 if the graph is unweighted)\n$ q $ is a parameter that determines the average number of trees. \n$ z $ is an integration constant. ","category":"page"},{"location":"#References","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"References","text":"","category":"section"},{"location":"#Functions-and-types","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"Functions and types","text":"","category":"section"},{"location":"","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","text":"Modules = [KirchhoffForests]\nOrder   = [:function, :type]","category":"page"},{"location":"#Base.:*-Tuple{KirchhoffForest, Matrix}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"Base.:*","text":"*(rf::KirchhoffForest, Y::Matrix)\n\nTreating the random forest as a linear operator, propagate the value of y at the root to the rest of the tree.\n\nExample\n\ng = grid([5])\nrf = random_forest(g, .5)\nrf*collect(1:nv(g))\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{Partition, Matrix}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"Base.:*","text":"*(p::Partition, Y::Matrix)\n\nTreating the graph partition as a linear operator, compute the average of Y over the partition.\n\nExample\n\ng = grid([5])\nrf = random_forest(g, .5)\np = Partition(rf)\np*collect(1:nv(g))\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.alias_draw-Tuple{PreprocessedWeightedGraph, Any}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.alias_draw","text":"Drawing procedure of alias method after the preprocessing Its cost is constant!\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.alias_preprocess-Tuple{SimpleWeightedGraphs.SimpleWeightedGraph}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.alias_preprocess","text":"This is the implementation of the preprocessing for the alias method.\nOverall cost for a graph is O(N^2)\nhttps://en.wikipedia.org/wiki/Alias_method\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.avg_rf-Tuple{Vector{Int64}, Vector{Float64}}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.avg_rf","text":"TODO: sum_by function is commented thus not in scope...\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.next-Tuple{KirchhoffForest}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.next","text":"next(rf::KirchhoffForest)\n\nReturn a vector of indices v, where v[i] = j means that node i points to node j in the forest. If v[i] = 0 i is a root.\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.random_forest-Tuple{Graphs.AbstractGraph, Any}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.random_forest","text":"random_forest(G::AbstractGraph,q)\n\nRun Wilson's algorithm on G to generate a random forest with parameter \"q\". q determines the probability that the random walk is interrupted at a node. If q is a scalar, that probability equals q/(q+d[i]) at node i with degree d[i]. If q is a vector, it equals q[i]/(q[i]+d[i]).\n\nExample\n\nusing Graphs G = grid([3,3]) random_forest(G,.4) q_varying = rand(nv(G)) rf = random_forest(G,q_varying) nroots(rf) next(rf) #who points to whom in the forest`\n\nTODO:\n\nAdd a rng parameter for reproducibility\nCode duplication for random_forest(G::AbstractGraph, q::AbstractFloat/AbstractVector), maybe define a function computing the acceptance to sink node\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.random_spanning_tree-Union{Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleGraph{T}, Integer}} where T","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.random_spanning_tree","text":"random_spanning_tree(g, [r])\n\nGenerate a (uniform) random spanning tree (https://en.wikipedia.org/wiki/Spanning_tree) using Wilson's algorithm (https://dl.acm.org/doi/10.1145/237814.237880). A spanning tree of connected graph g is a connected subgraph of g that's cycle-free, i.e. a tree that includes only edges from g and connects every node. If you specify the root of the tree, the function produces a spanning tree that is picked uniformly among all trees rooted at r. If you do not specify a root, the function produces a random tree from g, picking uniformly among all spanning trees of g (over all possible roots).\n\nNB: a graph must be connected in order to have a spanning tree. By default, the function checks that g is connected (in order to avoid an infinite loop). If you are positive g is connected, use force=true.\n\nArguments\n\ng: a graph\noptional: r, index of a node to serve as root\nforce: if true, skip connectivity test\n\nOutput\n\nIf the root is specified, returns a tree, represented as a SimpleDiGraph. If it isn't, returns a named tuple with \"tree\": the tree and \"root\": the root.\n\nExamples\n\njulia> g = cycle_graph(4)\n{4, 4} undirected simple Int64 graph\n\njulia> random_spanning_tree(g).tree |> edges |> collect\n3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 1\n\nTODO: Maybe consider the function randomspanningtree as a meta function with a switch wilson / aldous..\n\n\n\n\n\n","category":"method"},{"location":"#KirchhoffForests.smooth-Union{Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Vector, Any}} where T","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"KirchhoffForests.smooth","text":"smooth(g::AbstractGraph{T}, q, Y )\n\nSmooth signal over graph. Given a vector mathbfy of size nv(g), compute q(qmathbfI+mathbfL)^-1mathbfy, where mathbfL is the graph Laplacian and q > 0 is a regularisation coefficient (the smaller q, the stronger the smoothing).\n\nIf Y is a matrix then this function computes q(qmathbfI+mathbfL)^-1mathbfY. The linear system is solved using a direct method.\n\nExample\n\ng = grid([10])\nt = LinRange(0, 1, 10)\ny = sin.(6*pi*t)\nsmooth(g, .1, y)\nsmooth(g, 10.1, y)\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.SimpleGraphs.SimpleDiGraph-Tuple{KirchhoffForest}","page":"KirchhoffForests.jl: a Julia package for Random Forests on Graphs, and Applications","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph(rf::KirchhoffForest)\n\nConvert a KirchhoffForest rf to a SimpleDiGraph.\n\nExample\n\ng = grid([3,3])\nrf = random_forest(g,.4)\nf = SimpleDiGraph(rf)\nconnected_components(f)\n\n\n\n\n\n","category":"method"}]
}
